---
title: "17 面向可维护性的设计"
subject: 软件设计实践
---
# 代码复杂度
# 代码复杂度
## 圈复杂度
在函数/方法级别测量逻辑复杂度
衡量全面执行一个方法所需的测试数量
简单计算方法：#decisionPoints - # exitPoints+2 (决策点-返回点+2)
决策点：if while for的数量   &&被计算为两个决策点
返回点：return的数量
又可以画出流程图 边的数量-点的数量+2
# 设计模式 
## 简单工厂模式
建议一个工厂类，用于 创建不同的“产品”(不同子类的对象)
但是 违反了开放封闭原则
如果添加子类 需要在工厂类中进行修改
## 工厂模式
让每一个子类拥有一个工厂
添加新的子类时 增加新的工厂即可
将产品类的实例化操作延迟到工厂子类中完成
工厂父类定义创建产品对象的公共接口
容易冗余
## 抽象工厂模式
将抽象的集合聚集在一起
解决了具有二级分类的产品的创建
## 代理模式
为对象提供一种代理以控制对这个对象的访问
![[Pasted image 20250528140957.png]]
虚代理：在需要开销很大对象时缓存对象信息
远程代理：为一个对象在不同的地址空间提供局部代表
保护代理：用来控制真实对象访问时的权限
智能引用：当调用真实的对象 代理处理另外一些事
	适配器模式是为了解决接口不兼容问题
	代理模式是为了隔离对复杂对象的访问 不能改变所代理类的接口
	代理模式是为了隔离对复杂对象的访问 不能改变所代理类的接口
## 观察者模式
![[Pasted image 20250528142506.png]]
观察者模式(observer)定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新
高内聚低耦合的
当一个Subject被大量Observer订阅的话 广播通知时可能会有效率问题
## 访问者模式
访问者（ Visitor ）模式作用于某个对象群中各个对象的操作，可在不改变这些对象本身的情况下，定义作用于这些对象的新操作
![[Pasted image 20250528143653.png]]
适合用于结构已经定好 动态添加功能
## 状态模式
适合有多个状态且不同状态行为不同的情况
写一堆if-else维护性就会很差
状态（ State ）模式允许一个对象在其内部状态发生改变时改变其行为，使这个对象看上去就像改变了它的类型一样
![[Pasted image 20250528144624.png]]
