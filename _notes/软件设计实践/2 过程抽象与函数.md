---
title: "2 过程抽象与函数"
subject: 软件设计实践
date: 2025-6-11
---
**函数是对过程的抽象**
## 函数的声明与定义 
可在声明后定义 允许多次声明一个名字  
声明时形参名可省略 只声明形参类型即可
### 函数类型——返回值类型（形参类型）
e.g. `void (int)  int (int ,int)`  
**可用using 给函数类型起别名**   
e.g. `using IntFunc = int ( int , int ) `  
### 函数的规约（Specification)
定义:函数实现者和函数使用者之间的约定  
包含：  
&emsp;前置条件(precondition) ：对函数输入参数的规定  
&emsp;后置条件(postcondition)：对函数不同输入条件下的返回值和其他额外影响的规定  
#### 规约的描述方式
函数签名（function signature):函数名、参数类型、返回值类型  
函数描述：功能,对参数的限制条件,抛出的影响,其他影响   
在给定规约下，所有满足前置条件的输入，函数的返回值和额外影响都满足后置条件的约定  
函数实现者的责任：无需关心函数如何被调用 假设输入永远有效 根据规约满足后置条件   
函数调用者的责任：无需关心函数如何实现 假设函数的行为始终正确 根据约定的前置条件调用函数  
**规约屏蔽了函数的具体实现**  
`Rk:关于规约，可以访问[cppreference](https://en.cppreference.com/w/)点开任意一个函数来观察
### 如何设计函数
每个函数只做一件事  
![例子](https://raw.githubusercontent.com/dreaveler/dreaveler.github.io/master/_notes/软件设计实践/截屏/2.png)  
不写重复代码（DRY原则：Don't repeat yourself.） 
![例子](https://raw.githubusercontent.com/dreaveler/dreaveler.github.io/master/_notes/软件设计实践/截屏/2-2.png)  
一定泛化性  
结构化设计 将复杂过程解构为函数   
`Rk:这里的例子太过简单了，后面会讲一些更高级的抽象函数的方法。`  
### 缺省函数
定义函数时可给最右边连续若干个参数指定缺省值 相应位置不写参数时会以缺省值初始化  
```
void func (int x1, int x2 = 1, int x3 = 5);
func(10);  //func(10,1,5)
func(10,3);  //func(10,3,5)
```
### 函数重载
同一作用域内名字相同但形参列表不同的多个函数  
形参列表不同包括参数个数不同或参数类型不同  
```
int max(double f1 , double f2) // 1
int max(int n1 , int n2) //2
int max(int n1 , int n2 , int n3) // 3
```
如果由于类型自动转换或默认参数导致由好几个函数可以匹配 则会导致二义性问题  便难以错误  
```
max(1,2.5) //编译错误
```
编译器会根据调用语句中的实参个数和类型判断应该调用哪个函数  
复杂情况(个人认为有个印象理解一下即可 不太用记)： 
- T 类型的参数和 const T 类型的参数会被认为是相同类型  
- T *类型的参数和 T * const 类型的参数会被认为是相同类型  
- T & 类型的参数和 const T & 类型的参数会被认为是不同类型  
- T *类型的参数和 const T *类型的参数会被认为是不同类型  


**开放封闭原则：程序应对修改封闭，对扩展开放**（面向对象的五大原则之一，非常重要）  
`Rk：一个好的面向对象程序应当满足SOLID原则，具体内容后面会讲到`  
通过函数重载可以避免修改之前的函数 从而满足开放封闭原则 但个人感觉会有重复代码而造成的效率低下  
## 内存
内存地址：低——>高  
代码段（函数体）->数据段->堆->栈  
函数体 存放程序代码 函数指针  
数据段 存放全局变量 静态数据  
堆 由下往上 动态内存分配  
栈 由上向下压 每次函数调用创建栈帧 用于存放局部变量 函数参数等  
### 函数指针
将函数的入口地址赋给一个变量指针 使该指针变量指向函数 然后通过指针变量即可调用函数  
声明形式 ：`int (*ptr)(int,int)`  
注：括号不可省略   
可通过函数指针解地址运算符来调用  
`int max(int,int);`  
`int (*ptr)(int,int);`  
`ptr=&max;`  
`(*ptr)(3,5)`  
cpp可隐式转换到指向自身的指针  
即可：  
`ptr =max;`  
`ptr(3,5);`  
函数指针可以作为形参，形参中包含函数指针的函数一般称为高阶函数  
![例子](https://raw.githubusercontent.com/dreaveler/dreaveler.github.io/master/_notes/软件设计实践/截屏/2-3.png)  
## lambda表达式——只调用一次的简单函数，无需专门起名字
声明方式:`[捕获列表]（参数表）->返回值类型 {函数体}`  
函数体中可访问全局变量 但不能访问局部变量 如用 则需使用捕获列表  
- `[]` 不使用任何外部变量  
- `[=]`以传值的形式使用所有外部变量  
- `[&]`以引用形式使用所有外部变量
- `[x,&y]`x 以传值形式使用， y 以引用形式使用
- `[=, &x, &y]` x,y 以引用形式使用，其余变量以传值形式使用
- `[&, x, y]` x,y 以传值的形式使用，其余变量以引用形式使用


使用指针列表后不可转化为函数指针  
返回值类型(->)可以不写 由编译器自动判断  
语法糖  
e.g. `[](int x) -> int { return x*x*x; }`
