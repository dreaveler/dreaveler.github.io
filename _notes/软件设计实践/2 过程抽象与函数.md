---
title: "2 过程抽象与函数"
subject: 软件设计实践
---
**利用函数对过程进行抽象**
# 函数
## 函数的声明与定义 
可在声明后定义 允许多次声明一个名字  
声明时形参可省略
### 函数类型——返回值类型（形参类型）
e.g. `void (int)  int (int ,int)`  
**可用using 给函数类型起别名**   
e.g. `using IntFunc = int ( int , int ) `  
### 函数的规约（Specification)
定义:函数实现者和函数使用者之间的约定  
包含：
1. 前置条件(precondition) ：对函数输入参数的规定
2. 后置条件(postcondition)：对函数不同输入条件下的返回值和其他额外影响的规定
#### 规约的描述方式
函数签名（function signature):函数名 参数类型 返回值类型  
函数描述 功能,对参数的限制条件,抛出的影响,其他影响  
在给定规约下 所有满足前置条件的输入 函数的返回值和额外影响都满足后置条件的约定
规约屏蔽了函数的具体实现 
### 如何设计函数
每个函数只做一件事  
不写重复代码（DRY原则） 
一定泛化性  
结构化设计 将复杂过程解构为函数   
### 缺省函数
定义函数时可给最右边连续若干个参数指定缺省值 相应位置不写参数时会以缺省值初始化  
### 函数重载
同一作用域内名字相同但形参列表不同的多个函数  
形参列表不同包括参数个数不同或参数类型不同  
编译器会根据调用语句中的实参个数和类型判断应该调用哪个函数  
**开放封闭原则：函数应对修改封闭，对扩展开放**（面向对象的五大原则之一，非常重要）  
Rk：一个好的面向对象程序应当满足SOLID原则，具体内容后面会讲到
### 内存
内存地址：低——>高  
代码段（函数体）->数据段->堆->栈
函数体 存放程序代码 函数指针  
数据段 存放全局变量 静态数据  
堆 由下往上 动态内存分配  
栈 由上向下压 每次函数调用创建栈帧 用于存放局部变量 函数参数等  
### 函数指针
将函数的入口地址赋给一个变量指针 使该指针变量指向函数 然后通过指针变量即可调用函数  
声明形式  
`int (*ptr)(int,int)`  
注：括号不可省略   
可通过函数指针解地址运算符来调用  
`int max(int,int);`  
`int (*ptr)(int,int);`  
`ptr=&max;`  
`(*ptr)(3,5)`  
cpp可隐式转换到指向自身的指针  
即可：  
`ptr =max;`  
`ptr(3,5);`  
形参中包含函数指针的函数一般称为高阶函数
## lambda表达式——只调用一次的简单函数，无需专门起名字
声明方式
`[捕获列表]（参数表）->返回值类型 {函数体}`  
函数体中可访问全局变量 但不能访问局部变量 如用 则需使用捕获列表  
Rk:捕获列表有一些细则与简写，不确定时可以问问LLM。  
使用指针列表后不可转化为函数指针  
返回值类型可以不写 由编译器自动判断  
语法糖  
e.g. `[](int x) -> int { return x*x*x; }`
