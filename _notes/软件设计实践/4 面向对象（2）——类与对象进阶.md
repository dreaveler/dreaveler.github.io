---
number: 4
title: "4 面向对象（2）—— 类与对象进阶"
subject: 软件设计实践
date: 2025-6-23
---
## 对象数组
数组构造时每一个对象都会调用构造函数
`Test* p = new Test[2]{1 , (1 3)};`
调用两次构造函数  
`Test* pA[3] = {new Test(4), new Test(1,2) }`  
在这个过程中调用两次构造函数  
`Test* pA[3]` 实际上是开辟三个Test* 类型内存的空间，后面再分别构造两个Test，再把对应地址指上去  
对象数组生命期结束时 每个元素析构函数都会被调用  
### 析构和`delete delete[]`
`delete` 和`delete[]` 导致析构被调用  
`new` 对应`delete`  
`new[]` 对应`delete[]`  
## this 指针
成员函数中可以使用的一个特殊的指针变量，该指针指向调用成员函数的那个对象  
会在构造函数时生成一个内存空间存储this指针 指向调用成员函数的对象  
```
Complex(double real,double imag){
    this->real = real;
    this->imag = imag;
}
```
常用于在成员函数的返回值中返回调用函数的对象自身  使得函数可以链式调用  
## 对象作为成员列表
一个类的成员变量是另一个类的成员对象  
`Rk:这实际上表述了类与类之间的关系 我们将其称为组合关系，将类作为成员传入另一个类 则说明这个类与传入的类同时初始化同时析构 可以理解为人和人的脑袋的关系`
```
class CCar{
    int price;
    CTyre tyre;   //思考：这里用类的对象是合理的吗？
    CEngine engine;   //思考同上
public:
    CCar(int p,int tr,int tw){
        price = p;
        tyre = Ctyre(tr,tw)  //这里是初始化吗？不是，这里是赋值！
    }
}
思考答案：不合理 因为轮胎、发动机都是可以更换的 应该用指针更为合适 这样的关系我们称为“聚合”。
```
### 重新认识构造函数
成员变量的初始化是在执行构造函数之前 所以在执行构造函数的函数体那一刻起 每一个成员就有了自己的初始值（结合上面的例子）  

成员变量声明时可以附带默认初始化器 默认初始化器只能用大括号  
` int price{0};`
构造函数提供了一种特殊的方式 在声明后附加一个成员初始化列表  
`CCar(int price , int tr , int tw ): price {price }, tyre{tr , tw}`
对象初始化流程  
- 匹配构造函数  
- 若某个成员在初始化列表中提及 则按初始化列表中初始化值初始化  
- 若成员提供了默认初始化器 则按默认初始化器提供的初始化值初始化  
- 若某成员不满足上述条件 则默认初始化  
- 执行构造函数  


初始化成员顺序  
- 按照成员列表的顺序 与初始化列表书写顺序无关  
- 析构顺序与构造顺序相反  


若对象是用默认复制构造函数初始化的 那么它里面的成员也会用复制构造偶函数初始化  
## 静态成员
static关键字  
作用：类似全局变量或全局函数 把类当作命名空间来使用  
普通成员变量 每个对象各有一份  
静态成员变量 对于每个类就只有一份  
静态变量不需要通过对象就能访问 可以直接通过类名:: 静态成员名访问  
成员列表中的静态成员变量大多只能是声明而非定义  
**需要在类外定义它**（不带static）  
静态成员函数中不能访问非静态成员变量 也不能调用非静态成员函数  
静态成员函数中不能使用this指针  
## 只读成员
定义该对象时在前面加const关键字 声明为只读对象  
只读对象只能调用构造函数、析构函数、有const说明的函数（只读成员函数）  
只读取成员变量值不可修改 （除非用mutable修饰）  
一般作为函数形参 避免函数修改对象  
### 只读成员函数
在成员函数说明后面加const关键字 称为只读成员函数  
内部不可改变该类的成员变量的值 也不能调用该类中的非只读成员函数  
可修改静态成员变量的值 或调用静态成员函数  
声明和定义时都必须使用const关键字  
const算作重载 哪怕两个函数名字和参数列表都一样 一个是const 一个不是 也算作重载  
#### mutable成员变量
用mutable关键字修饰的可以在const成员函数中修改  
```
class CTest{
public:
    bool getData() const{
        n++;
        return flag;
    }
private:
    mutable int n;
    bool flag;
}
```
### 只读成员变量
没有办法通过任何方式被赋值（在构造函数和只读函数中也都不行）  
必须被显示地初始化 即必须有默认初始化器 或出现在成员初始化列表中  
## 友元
让某个类以外的函数访问该类的私有成员  
友元函数：一个类的友元函数可以访问该类的所有私有成员  
![例子](https://raw.githubusercontent.com/dreaveler/dreaveler.github.io/master/_notes/软件设计实践/截屏/4-1.png)    
友元类：如果A是B的友元类 则A的所有成员函数都可以访问B的私有成员  
![例子](https://raw.githubusercontent.com/dreaveler/dreaveler.github.io/master/_notes/软件设计实践/截屏/4-2.png) 
friend关键字 在类A的成员列表中把f抄一遍 加上friend关键字 即为友元  
