---
title: "1 数据抽象与类型系统"
date: 2025-02-19
subject: 软件设计实践
---
# 从C到cpp 数据抽象与类型系统
#### 语言处理程序 
编译-cpp 解释- python
内存 1B=8bit
内存地址 每个内存对应一个内存地址。由0开始计数
机器语言/汇编语言 由内存地址访问内存中的数据
高级语言 给内存位置起一个名字 通过名字访问数据
### 数据类型
定义：一组性质相同的值的集合以及定义在这个值集合上的一组操作
类型标识 eg.`int double char[10] int *`
类型别名：`using 别名=类型标识`
eg `using IntPointer=int *`
优点：
1. 提前避免错误
2. 编译器可针对类型信息进行优化  

缺点：增加工作量
#### 变量在声明时发生了什么
1. 找到能承载变量长度的内存空间
2. 将变量名绑定到这块内存空间
3. 对这块内存空间的内容初始化（若没有指定初始化 则依赖空间自身行为进行初始化）
#### cpp有多种初始化方法 
`T a1 {} `
`T a1 ={} `
`T a1 ()`
`T a1 = `
cpp11采取了同一初始化 即第一种方式 
优点：防止窄缩 （数据转化后再向内转化而不能得到原有表示的情况）
若同一初始化 编译期间会强制检查 若发生窄缩则编译失败
初始化：仅开空间绑定变量时的行为
#### 引用
定义：某个变量的引用等价于这个变量，相当于该变量的别名(指向地址)
e.g.
```
int n=4;
int &r=n;
r=3;
r=? 答案：3
n=? 答案：3
```
注意事项：
1. 定义时必须引用 
2. 2. 引用后便只指向该位置

`*`取地址 `&`解地址
#### auto
用于定义变量 编译器可以自动判断类型 
使用auto定义必须马上初始化
auto不能定义数组
#### 常量与const关键字
编译期间就能确定的值 不会发生变化 字面量 eg `3 42 'a' "aaaa"`
只读变量 用`const`修饰 该变量值 不能改变 初始化时不能省略初始化器
只有使用常量作为初始化值的只读变量才是常量
`constexpr`声明的变量一定是常量
##### const与引用('&'(读作花))
定义引用时 前面加`const`关键字 即“只读引用”
不能通过只读引用去修改其引用的内容（其引用内容本身可以修改）
`const T&` 与`T&` 不同
`T&` 可以用来绑定到`const &`，反之不可
##### const与指针('*'(读作星))
在类型前加const即`const T*` 可理解为指向只读变量的指针
即不可通过该指针去修改其指向的内容，但指针指向可以变化
在类型后加const，即`T* const` 
指针指向不可变化 但可通过指针去修改其指向内容
#### 动态内存分配 
动态分配变量
```
T* p=new T
delete p
```
动态分配数组(可以用变量名来开长度)
```
T* p=new T []
delete T[]
```