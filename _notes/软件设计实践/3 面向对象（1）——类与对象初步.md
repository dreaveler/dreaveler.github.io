---
title: "3 面向对象（1）—— 类与对象初步"
subject: 软件设计实践
---
# 类
将数据结构和操作该数据结构的函数捆绑在一起 即“封装”   
### 类的成员
成员变量  
成员函数  
通过类定义的变量，称为类的实例，又叫“对象”  
通过 `.` 运算符可以调用成员变量和成员函数  
使用对象可简化书写  
    减少全局名字  
    使结构程序更清晰  
#### 对象更重要的是提供了一种新的抽象手段
对象的行为无需依赖全局变量  
对象之间可以直接交互来完成功能 无需依赖外部函数  
#### 基本方法：
将某类共同特点归纳出来，形成一个数据结构；  
将行为也归纳出来，形成函数  
利用类进行捆绑封装  
### 类的定义和使用：
class 类名{ ........}； 类名一般首字母大写  
范围说明符：public private protected（class不写默认是public)  
成员函数和成员变量出现的先后次序没有规定  
在类的定义外定义成员函数 函数名前加 类名::  
每个对象有各自的存储空间用于保存成员变量  
成员函数并不是每个函数都各有一份  
#### 访问成员名 ： 
对象名.指针名
指针->成员名
```
A a;
A* r1=&a
r1->t=5；
```
引用名.指针名  
函数传递时避免大量的复制  
类成员可被访问的范围：  
`  `private :只能在一个类中被使用  
`  `public：在任何地方可以使用  
`  `protected：保护成员 暂且不表  
私有成员可实现"信息隐藏"    
`  `强制对成员变量的访问一定通过成员函数规定（规约）  
`  `方便修改成员变量类型属性——只需修改成员函数（可扩展性）  
用struct定义类 未说明默认为共有而class默认为私有  
### 对象的生命周期
变量的生命周期  
函数传参：执行复制初始化 函数执行结束后立即销毁  
函数返回值：自动生成一个临时变量 函数复制初始化  
#### 构造函数：  
名字必须与类名完全相同 可以有参数 但不能有返回值（void也不行）  
作用：不必专门再写初始化函数   
若没写构造函数 编译器自动生成一个默认的无参数的构造函数  
可通过重载构造多个构造函数  
最好public  
Rk：当使用private时如果要产生一个对象必须要有一个public的工厂函数以让外界访问  在一些情况下很有用  
单例模式  
Rk：设计模式之一，后面会讲。  
#### 复制构造函数  
若构造函数只有一个参数 是对同类对象的引用 这样的构造函数称为复制构造函数   
形如X::X(X&) 或 X::X(const X&)  
Rk：个人建议一律写后者 因为结合定义来看不应对变量进行修改  当然oj中出的题另当别论  
对于每一个相应的赋值  
被调用的三种情况：  
`  `用一个对象取初始化同类的另一个对象  
`  `如果函数有一个参数是类的对象 那么该函数被调用时 类的复制构造被调用  
`  `函数的返回值是对象 函数返回时 函数的复制构造函数被调用  
#### 类型转换构造函数
类型转化   
`  `显式类型转换：利用类型转换运算符明确表示类型转换  
`  `隐式类型转换：编译器发现某类型不符合语境 自动进行类型转换  
构造函数可以用于实现类型转换   
`  `被转换的类型与构造函数的参数类型匹配时会自动调用  
`  `自动构造调用函数 建立一个无名的临时对象  
explicit 关键字  
`  `在构造函数前加explicit 可以使该构造函数只能用于显式类型转换 不能用于隐式类型转换  
将不加explicit关键字的称为类型转换构造函数  
#### 析构函数  
名字与类名相同 前加~  
`  `没有参数和返回值  
`  `一个类最多只有一个返回值  
析构函数在对象消亡时自动被调用  
可以定义析构函数在对象消亡前做善后工作，比如释放分配的空间等  
如果定义类时没写析构函数 则编译器会生成缺省析构函数  
`  `自动生成的什么也不做  
参数对象消亡时也会导致析构函数被调用  
函数return时 生成的临时对象也会调用  
