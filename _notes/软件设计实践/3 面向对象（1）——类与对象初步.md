---
title: "3 面向对象（1）—— 类与对象初步"
subject: 软件设计实践
date: 2025-6-22
---
# 类
将数据结构和操作该数据结构的函数捆绑在一起 即“封装”   
![例子](https://raw.githubusercontent.com/dreaveler/dreaveler.github.io/master/_notes/软件设计实践/截屏/3-1.png)  
## 类的成员
成员变量  
成员函数  
通过类定义的变量，称为类的实例，又叫“对象”  
`Rk：所谓面向对象，就是对类的实例进行操作。`  
通过 `.` 运算符可以调用成员变量和成员函数  
```
Rational r;  //Rational即类名  r就是对象
r.init(2,3);
r.num;
r.denom();
```
使用对象可简化书写：  
&emsp;减少全局名字（即全局变量）  
&emsp;将有关系的变量和函数合并到一起，使结构程序更清晰  
#### 对象更重要的是提供了一种新的抽象手段
对象的行为无需依赖全局变量  
对象之间可以直接交互来完成功能 无需依赖外部函数  
### 基本方法：
- 将某类共同特点归纳出来，形成一个数据结构；  
- 将行为也归纳出来，形成函数  
- 利用类进行捆绑封装  


分析不同类之间的关系 利用对象之间的交互实现功能  
#### 不同的程序设计方法
- 面向对象程序设计 特别适合可以拆分为多个独立部分、不同部分之间相互交互的系统开发  
- 结构化程序设计：对输入数据以及输出数据之间的变换关系提供了直观而自然的描述 例如写算法题时  


## 类的定义和使用：
class 类名{ ........}； 类名一般首字母大写  
范围说明符：public private protected(class不写默认是public)  
成员变量以及函数的声明和定义与普通变量、声明相同  
成员函数和成员变量出现的先后次序没有规定  
在类的定义外定义成员函数 函数名前加 类名::  
```
class CRectangle{
public:
int w , h
int area ();
int perimeter();// 成员函数在此仅声明
void init(int w_, int h_);
};
int CRectangle::area (){
return w * h;
}
int CRectangle::perimeter (){
return 2 * (w + h);
}
void CRectangle::init(int w_w_, int h_h_){
w = w_;
h = h_;
}
```
每个对象有各自的存储空间用于保存成员变量  
成员函数并不是每个函数都各有一份而是统一存放，但可以作用于不同的对象  
### 访问成员名
对象名.指针名  
指针->成员名  
```
A a;  
A* r1=&a;  
r1->t=5;  
```
引用名.指针名 使得函数传递时避免大量的复制  
#### 类成员可被访问的范围：  
private :只能在一个类中被使用  
public：在任何地方可以使用  
protected：保护成员 暂且不表  
私有成员可实现"信息隐藏"    
强制对成员变量的访问一定通过成员函数规定（规约）  
方便修改成员变量类型属性——只需修改成员函数（可扩展性）  
用struct定义类 未说明默认为共有而class默认为私有  
## 对象的生命周期
变量的生命周期  
函数传参：执行复制初始化 函数执行结束后立即销毁  
函数返回值：自动生成一个临时变量 函数复制初始化  
### 构造函数：  
名字必须与类名完全相同 可以有参数 但不能有返回值（void也不行）  
作用：不必专门再写初始化函数   
若没写构造函数 编译器自动生成一个默认的无参数的构造函数，默认构造函数什么也不做   
当自己定义了一个构造函数 则编译器不生成默认的构造函数 
可通过重载构造多个构造函数  
最好public  
Rk：当使用private时如果要产生一个对象必须要有一个public的工厂函数以让外界访问  在一些情况下很有用  
单例模式——一个类只能有一个对象  
Rk：设计模式之一，后面会讲。  
### 复制构造函数  
若构造函数只有一个参数 是对同类对象的引用 这样的构造函数称为复制构造函数   
形如X::X(X&) 或 X::X(const X&)  
Rk：个人建议一律写后者 因为结合定义来看不应对变量进行修改 当然oj中出的题另当别论  
不写的话同样会生成一个默认的复制构造函数 作用是对每一个成员进行复制初始化  
被调用的三种情况：  
用一个对象取初始化同类的另一个对象  
```
Complex c2(c1);
Complex c3 = c1;   //均为初始化语句
```
如果函数有一个参数是类的对象 那么该函数被调用时 类的复制构造被调用  
```
void func(Complex c)  
//潜在问题是什么？复制构造函数可能修改 
//如何解决？ 复制构造函数使用const A&
//个人更推荐直接传引用()
```
函数的返回值是对象 函数返回时 函数的复制构造函数被调用  
```
A func(){
    A b(4);
    return b; //经过优化的编译器可能不会生成临时对象
}
```
### 类型转换构造函数
类型转化   
C++是弱类型语言 表达式中经常发生类型转换 有以下两种形式
&emsp;显式类型转换：利用类型转换运算符明确表示类型转换  
&emsp;隐式类型转换：编译器发现某类型不符合语境 自动进行类型转换  
构造函数可以用于实现类型转换   
被转换的类型与构造函数的参数类型匹配时会自动调用  
自动构造调用函数，建立一个无名的临时对象  
explicit关键字：在构造函数前加explicit 可以使该构造函数只能用于显式类型转换 不能用于隐式类型转换  
将不加explicit关键字的称为类型转换构造函数  
### 析构函数  
名字与类名相同 前加~  
没有参数和返回值  
一个类最多只有一个析构函数  
析构函数在对象消亡时自动被调用  
可以定义析构函数在对象消亡前做善后工作，比如释放分配的空间等  
如果定义类时没写析构函数，则编译器会生成缺省析构函数，自动生成，什么也不做  
参数对象消亡时也会导致析构函数被调用  
函数return时 生成的临时对象也会调用    
![例子](https://raw.githubusercontent.com/dreaveler/dreaveler.github.io/master/_notes/软件设计实践/截屏/3-2.png) 