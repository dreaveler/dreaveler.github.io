# 软件复用
将已有软件以及有效成分用于构造新的软件
复用的优点：etc
复用的代价：
	需要学习
	复用的代码可能存在漏洞/后门
开发可复用的软件
	要有足够高的适应性 开发成本高于一般性
	针对普适的场景进行开发 缺少足够针对性
复用已有软件
	需要做适配
#### 白盒复用
复制已有代码 并进行修改
可定制化程度高
增加了软件复杂度 需要充分了解内部实现
### 黑盒复用
通过接口来复用已有的代码 无法修改
简单清晰
某些情况适应性差
#### 复用的形态
源代码(sourece code)
	复制粘贴代码
	可能存在问题
	github上搜索
模块（Module）
	复用函数/类
	可能的问题：版本更新导致后向兼容问题  需要将相关类和函数链接在一起
	复用类的两种方式
		继承
		委托：将某些职责由其他类来完成
库(Library)：提供可复用功能的一组类/函数
库提供的类和函数常被称为API(Application Programming Interface 应用编程接口)
开发者调用库提供的API
框架(Framework)：
根据提供的规约 将自己编写的代码填充到框架中 形成完整的软件
# 设计可复用的类
回顾对象间的关系
### 通过继承实现复用
子类可以继承父类已有的功能 在此基础上增加子类的特殊功能 从而实现复用
需要符合里氏替换原则 LSP
继承复用的基石
按照行为进行继承
### 通过委派实现复用
类B对象使用类A对象的功能
通过某种方式将类A的对象传入B 中 B就可以调用A的函数
如指针等等
### 继承与委派
继承和委派同时使用 来实现特定的设计目标
继承发生在类的层面  委派发生在对象的层面
合成复用原则——优先使用委派而不是继承来实现复用
	原因是降低类与类之间的耦合度
	继承会破坏系统的封装性
实践方法：
	通过抽象类或接口来实现委派 兼具可复用性和可扩展性
# 设计模式
## 适配器模式
我们假设已经实现了双向队列Deque
在此基础上想实现栈和队列
把功能多的类实现特定场景的有限功能的类
适配器模式希望将一个类的接口转换成用户希望的另一个接口 使得原本由于接口不兼容而不能一起工作的类可以一起工作
分为类适配器以及对象适配器
类适配器用一个具体的Adapter来对Adaptee以及Target来进行适配  Adapter多继承自Adaptee以及Target
对象适配器使用组合或聚合将Adaptee的对象添加到Adapter中 允许一个Adapter与多个Adaptee同时工作
## 装饰器模式
假设已经实现了通知器类 Notifier ，可以在收到信息时向目标邮箱发送通知，希望在此基础上扩展功能  如通知微信 QQ 等 
如果要获得目标的任意组合要怎么做
将每一个特性构造子类 通过委派机制增加到对象上
装饰器模式动态的添加职责
![[Pasted image 20250521142209.png]]
![[Pasted image 20250521142241.png]]
Concrete是基础功能
与其余装饰用功能不在同一层级
使用场景  不影响其它对象的情况下 以动态、透明的方式给单个对象添加职责 
优缺点 很容易的添加职责 具有低依赖性和低复杂性 缺点是产生了许多小对象
# 外观模式
通过提供一个统一接口 用来访问子系统中的一群接口
本质是让接口变得更简单 接触依赖性 有利于移植和更改
![[Pasted image 20250521142921.png]]
对客户端屏蔽子系统组件
不限制客户应用子系统类
## 策略模式
有多种算法来实现同一个任务 但需要根据需要动态切换算法 如何实现灵活替换？
首先是肯定不能放到一个函数里的
策略模式定义一系列算法把他们封装起来并且相互之间可相互替换
![[Pasted image 20250521143324.png]]
优缺点：
复用性好 便于维护
客户必须了解不同的strategy
通信开销大
## 模板方法模式
定义操作中算法的骨架
将一些步骤的执行延迟到子类中
子类无需改变算法结构即可重定义算法的某些步骤
![[Pasted image 20250521143934.png]]
代码复用技术
形成反向的控制结构（依赖倒置原则）
父类调用子类的操作 高层调用低层 低层实现高层模块声明的接口
控制权在父类 底层模块反而需要依赖高层模块
可以通过钩子方法对某些步骤进行挂钩 

策略模式是利用不同算法解决的是同一问题 
模板方法模式是形成一个完整的算法框架
