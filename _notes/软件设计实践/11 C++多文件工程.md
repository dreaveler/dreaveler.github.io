tag: #多文件
对于大的函数，如果修改其中一个函数，在生成exe时会同时编译两个函数，这样的开销是很大的，所以考虑进行把不同函数分到不同文件里
## C++多代码文件的组织
#### 代码文件分类
##### 头文件 .h
一般只存放类型的定义和符号的声明
	不会产生任何二进制指令
##### 实现文件 .cpp
存放对应头文件声明的定义
	作为程序执行入口 只会包含必须头文件
#### 预处理指令
以#开头以换行符结尾是预处理指令 在编译之前完成特定的替换任务
`#include`是把某个源文件直接插入指令所在位置
	效果类似于文件内容拷贝
`#include<头文件名>`优先在系统库里寻找
`#include"头文件名"`优先在源文件库中寻找
多次`#include<头文件名>`会报重定义错误
	解决方案
	预处理命令
	`#define  #if  #elif  #else  #endif  #ifdef  #ifndef`使得编译器选择性编译
#### 条件编译
`#if`若常量表达式为非0值 则编译代码1 但不编译代码2 `#else`可省略
```
#if 常量表达式
代码1
#else
代码2
#endif
```
`defined`可以返回当前环境是否定义了宏  若宏存在 值为1  否则0
```
#ifdef = #if defined
#ifndef = #if !defined
```
#### 命名空间
在不同头文件中声明了名字相同的变量/函数时
可以通过写命名空间
namespace lib1{
}
来在文件中访问
自定义命名空间一般 在头文件中完成  当类的声明在命名空间中时 需要在命名空间外定义
作用域解析符
命名空间::名字
#### 单一定义原则
一个翻译单元中 允许多次声明 只允许一次定义
一个翻译单元  如果ODR使用  最少出现一次定义
整个程序 非内联最多只出现一次定义
## 命令行
当前主体是GUI 早期只有命令行界面(CLI) 使用终端模拟器在GUI上使用CLI
#### 命令行参数
命令的格式
程序名 空格 参数 1 空格 参数 2 空格...
###### 每一个命令按空格分为若干段 
第一段称作“程序名”，其指定了一个程序， Shell 会在 CLI 中启动这个程序，然后将输入输出的控制权交给它
剩下的部分称为命令的“参数”，这些参数将在程序启动时通过一种特别的方式传入程序，而程序可以通过一些方法获得这些参数
###### C/C++ 程序利用 main 函数的参数获取命令行参数
argc ：代表启动程序时，命令行参数的个数 C/C++ 语言规定，可执行程序本身的文件名，也算一个命令行参数，因此 argc 的值至少是 1
argv ：指针数组，其中的每个元素都是一个 char* 类型的指针，该指针指向一个字符串，这个字符串里就存放着命令行参数（ `argv[0]` 始终是程序名本身）
###### 工作路径
需要在特定的路径中工作  可以通过cd来更换  .代表当前路径 ..代表上一级
--PATH环境变量
###### 命令行重定向
重定向输出> 将标准输出重定向到a.exe中
`test.exe>out.txt`
重定向输入< 将in.txt中的内容重定向到标准输入中
`test.exe<in.txt`
#### 命令行编译
以g++为例  指定多个编译单元 会分别编译这些单元并自动链接  最后存放在.exe中
-o 选项指定了编译结果在哪里
`g++ ./main.cpp ./hello.cpp -o ./main.exe`
![[Pasted image 20250418114120.png]]
#### MAKE 工具
##### GNU Make 经典构造工具
使用makefile文件  不带后缀名  
其中格式：
```
目标文件:依赖文件1 依赖文件2 ...
	生成命令
```
生成名前为一个tab
##### CMake 
通过CMakeLists.txt脚本来生成Mkaefile
第一行规定了最低CMake版本
第二行指定了项目名称
第三行add_executable告诉CMake 
## 文件读写
文件和流
包含头文件<fstream>
创建文件 ofstream是头文件中定义的类
outFile是创建的对象
路径 以及打开并建议文件的选项  ios::out删除原有内容 输出到文件
ios::app  输出到文件  保留原有内容  在尾部
ios::ate  输出到文件  保留原有内容  在文件任意位置
也可以先创建对象  再用open函数打开
```
#include <fstream > // 包含头文件
ofstream outFile ("clients.dat", ios ::out);
```
##### 文件读写指针
标注文件操作位置  指针在哪里 操作在那里进行
.tellp()函数取得写指针的位置
seekp()函数移动指针
