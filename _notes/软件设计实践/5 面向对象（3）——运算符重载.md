---
title: "5 面向对象（3）—— 运算符重载"
subject: 软件设计实践
date: 2025-6-23
---
## 基本概念
C++本身定义了多种运算符 包括：+ - * / = % ^ & ~ etc
运算符重载：对于C++中定义的运算符赋予了多重含义 使同一运算符作用于不同数据类型的数据时可以有不同的行为  
**运算符重载的本质是函数重载**
```
返回值类型 operator运算符（形参表）{
	......
}  
```
可以重载为类的成员函数 也可以重载为普通函数
- 重载为类的成员函数时参数个数为运算符目数减一
![例子](https://raw.githubusercontent.com/dreaveler/dreaveler.github.io/master/_notes/软件设计实践/截屏/5-1.png) 
- 重载为普通函数时参数个数=运算符目数
![例子](https://raw.githubusercontent.com/dreaveler/dreaveler.github.io/master/_notes/软件设计实践/截屏/5-2.png) 
- attached：`[]`为双目运算符


### 赋值运算符——“=”
要求两边操作数的类型是匹配的
有时候希望=两边的类型不兼容也能成立 就需要重载
c++规定 =只能重载为成员函数
**生效是赋值阶段 如果初始化阶段复制构造函数没有对应函数/类型转换构造函数时会报错**
同时具有类型构造函数和相同类型的赋值运算符重载时 优先使用重载的赋值运算符 所以有转换构造函数时一般无需写重载赋值运算符  
赋值运算符中需要先delete 再new 出来
当类中定义赋值运算符重载时 编译器会生成一个预制的重载的赋值运算符使得同一个类之间可以使用=运算符赋值  **浅复制** 
因此要自己定义赋值运算符重载
自赋值有可能套娃（加一个if判断即可）
赋值与初始化的区别
	初始化是从零到一
	赋值是从一到一 需要有抛弃旧值的过程
移动语义
我们希望连续使用 就需要返回* this 
### 类型转换重载
加入要实现从A到B类型的类型转换 而A是类 那么可以在A中定义 operator B(){...} 实现类型转换
	必须为成员函数 形参为空 不指定返回类型 
	一般不转变对象 因此常定义为const
	类型转换时自动调用
	加上explicit则只能用于显式转换
### 非成员的运算符重载
#### 重载为友元
有时重载为成员函数不能满足使用要求
这时可以重载为普通函数
但普通函数无法访问私有成员 故声明为友元
也可以进行类型转换
#### 流插入/流提取运算符的重载
为什么cout<<5<<"this"能够成立
	cout是iostream中定义的ostream类的对象
	<<之所以用在cout上是因为对<<进行了重载
	重载了多次才能既输出整数又能输出字符串
	连续使用<<是因为最后返回了* this 
如何使得cout可以输出自定义类型的数据
重载为普通函数
ostream &operator<<(ostream &os, const Complex &c){
	os<<c.real<<"+"<<c.image<<"i";
	return os;
}
### 特殊运算符的重载
#### 子增减运算符的重载
注意有前置后置之分
	前置运算符作为一元运算符重载
		前置“增加然后取回值” 对象值和取回值均为增加后的值（定义时使用引用）
	后置运算符作为二元运算符重载
		后置“取回然后增加” 取回值为原值 对象值为增加后的值（定义时不用引用 就是对象）

函数调用运算符的重载
	函数调用运算符（即f(a,b,c)中的括号） 也可以被重载
	函数调用运算符最少是一目的运算符 
		T operator()(// 任意多个参数的列表)
	只能以成员函数形式重载
	作用：
		使得对象也可以像函数一样被调用
		像这种重载了函数调用运算符的对象为函数对象(function object)


previous:[[4 面向对象（2）——类与对象进阶]]
next:[[6 面向对象（4）——继承]]
related：[[4 面向对象（2）——类与对象进阶]]  [[3 面向对象（1）——类与对象初步]]  [[6 面向对象（4）——继承]]   [[7 面向对象（5）——多态]]