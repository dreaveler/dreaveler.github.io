tag: #泛型程序设计
函数重载可以复用函数名字 减少了函数调用的复杂度 但哪怕这样 还是有很大的任务量 可不可以减少编写重复的函数实现代码？
### 泛型程序设计
编写代码时不指定具体的数据类型 而是使用抽象类型来编写 实例化时再提供参数来指明类型
优点
	减少重复代码编写
	提高代码可复用性
#### C++泛型程序设计
使用**模板**(Template)设计程序
	函数模板
	类模板
标准模板库（STL）
一些常用数据类型和算法模板的集合
## 函数模板
#### 函数模板是提供生成函数能力的语法
```
template<模板形参表>
返回值类型 函数模板名（函数形参表）{
函数体
}
```
模板形参表是由一系列逗号分隔的模板形参
	类型模板形参 typename 形参名 或 class 形参名
	非类型模板形参
在函数模板的返回值类型、函数形参表、函数体中可以使用模板形参名来指代数据类型
```
template<typename T>
void print(T x) {
	cout<<x<<endl;
}
```
#### 从函模板生成函数的过程称为函数模板的实例化
实例化发生在编译时
已实例化的不会重新实例化
上面是隐式的实例化 
##### 通过模板形参进行实例化为显式的实例化
```
函数模板名<模板实例化>(函数实参表)
```
`print<int>(42)`
##### 函数模板实参推导(Function Template Argument Deduction ,TAD)
调用函数模板时省略模板形参  可根据函数实参推导模板形参的值 
赋值兼容原则会引起函数模板中类型函数的二义性
#### 函数模板的重载
函数模板同样可以重载 只要函数形参或模板形参表不同即可
##### 函数和模板的匹配顺序
先找一个参数完全匹配的普通函数
再找函数模板
再在没有二义性的前提下 寻找经过自动类型转换的普通函数
## 类模板
类模板是能生成类的语法
规则与函数模板相同
在类模板的成员列表、成员函数中可以使用模板形参名来指代数据类型
同样可以使用类模板实参推导完成实例化 但一般在类的实例化中确认形参
##### 类模板中的函数模板
类模板中的成员函数可以是一个函数模板
在类外定义时 需要写先写类的template 再写函数模板的template
#### 类模板与派生
类模板可以从类模板、模板类、普通类派生
普通类也可以从类模板派生
## 非类型模板参数
模板参数不一定是类型 还可以变量 用于替换模板中的变量
由于模板的实例化实在编译期间完成 所以模板实参必须是常量
非类型模板参数可以提高程序的执行效率
## 标准模板库(STL)
#### C++标准
伴随编译器提供给程序员的一系列已编译好或尚未编译的代码 并在标准库头文件中对这些代码进行了声明
标准模板库(STL)
	一套基于模板的C++库 1994年被并入C++标准
### 程序的需求
存储数据 容器
读写数据 迭代器
操作数据 算法
#### 容器
用于存放各种类型的数据 都是类模板
容器分为三种
	顺序容器: vector deque list 
	关联容器
		有序关联容器：set multiset map multimap
		无需关联容器: unordered_map...
	容器适配器:stack queue priority_queue
对象被插入时 插入的是复制品
##### 顺序容器
插入位置同元素的值无关 顺序可以被控制
vector 动态数组 尾端增加具有较佳性能(常数时间)
deque 双向队列 两端增删元素较佳
list 双向链表 任何位置增删元素常数时间 不支持随机存取
###### 迭代器
用于指向顺序容器和关联容器中的元素
迭代器用法与指针类似 有const和非const两种 通过迭代器读取 非const还可以修改其指向的元素
定义方法
	`容器类名::iterator 迭代器变量名`
	`容器类名::const_iterator 迭代器变量名`
访问指向元素 `*迭代器变量名`
可以使用++操作
###### 算法
STL提供通用算法 大多在algorithm头文件中定义
通过迭代器来操纵容器中的元素


previous:[[7 面向对象（5）——多态]]
next:[[9 C++泛型程序设计（2）——STL基础]]