从C到cpp 数据抽象与类型系统
语言处理程序 编译-cpp 解释- python
内存 1B=8bit
内存地址 每个内存对应一个内存地址。由0开始计数
机器语言/汇编语言 由内存地址访问内存中的数据
高级语言 给内存位置起一个名字 通过名字访问数据

数据类型：一组性质相同的值的集合以及定义在这个值集合上的一组操作

类型标识 eg。int double char[10] int *
类型别名：using 别名=类型标识
eg using IntPointer=int *
优点 
	提前避免错误
	编译器可针对类型信息进行优化
缺点 增加工作量


变量在声明时发生了什么
1.找到能承载变量长度的内存空间
2.将变量名绑定到这块内存空间
3.对这块内存空间的内容初始化（若没有指定初始化 则依赖空间自身行为进行初始化）
？一个文件本身有固定大小的内容空间吗 

cpp有多种初始化方法 
	T a1 {} 
	T a1 ={} 
	T a1 ()
	T a1 = 
cpp11采取了同一初始化 即第一种方式 
优点：防止窄缩 （数据转化后再向内转化而不能得到原有表示的情况）
若同一初始化 编译期间会强制检查 若发生窄缩则编译失败
初始化：仅开空间绑定变量时的行为

引用：某个变量的引用等价于这个变量，相当于该变量的别名(指向地址)
eg 
	int n=4;
	int &r=n;
	r=3;
	r=?  3
	n=? 3
注意事项：1. 定义时必须引用 2. 引用后便只指向该位置
星取地址 &解地址

auto 用于定义变量 编译器可以自动判断类型 
使用auto定义必须马上初始化
auto不能定义数组

常量：编译期间就能确定的值 不会发生变化 字面量 eg 3 42 ‘a’ “aaaa”
只读变量 用const修饰 该变量值 不能改变 初始化时不能省略初始化器

只有使用常量作为初始化值的只读变量才是常量

constexpr  声明的变量一定是常量

定义引用时 前面加const关键字 即为”只读引用”
不能通过只读引用去修改其引用的内容（其引用内容本身可以修改）

const T & 与T & 不同
T & 可以用来绑定到 const T &
反之 不行

在类型前加const 可理解为指向只读变量的指针
即不可通过该指针去修改其指向的内容
但指针指向可以变化

在类型后加const 指针指向不可变化 但可通过指针去修改其指向内容

动态内存分配 

动态分配变量
T 星 p=new T
delete p

T 星 p=new int []
Delete int[]




